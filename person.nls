
;;
; persons



to-report can-play? [s sp]
  let temp1 random-float ratio-speed-fast-slow
  let temp2 random-float max-speed-patch

  report temp1 < s and temp2 < sp
end



;;
; core persons procedure : follow the gradient of the shortest path associated to the turtle
;   - test noise in mvt
;   - todo add the presence of walls in the guiding field (or add redirection in agents ?)
to downhill-shortest-path [id]

    let tempI 0
    ;move-to max-one-of patches in-cone 1 180 [item id shortest-path-t]
    let temp min-one-of neighbors with [item (item id direction) obstacle = 0] [item id shortest-path-t]
    let ok? true
    ask temp [
      if item (item id direction) obstacle > 0 [set ok? false]
      if count persons-here  with [delay <= ticks and not has-arrived?] > 0 [;?
      set ok? false
      set interaction interaction + 1
      set tempI 1
     ;
      ]
    ]
    ifelse ok? [
      set heading towards temp
      move-to temp
    ][
       let temp2 min-one-of neighbors with [item (item id direction) obstacle = 0 and pxcor != [pxcor] of temp and pycor != [pycor] of temp] [item id shortest-path-t]
    let ok?2 true
    if is-patch? temp2 [ask temp2 [
      if item (item id direction) obstacle > 0 [set ok? false]
    if count persons-here with [delay <= ticks and has-arrived? = false] > 0 [
    ;  set interaction interaction + 1
     ; set tempI 1
      set ok? false]
    ]
    if ok?2 [
      set heading towards temp2
      move-to temp2
      ]]

      if not ok?2 [
        if any? neighbors with [item (item id direction) obstacle = 0 and persons-here with [delay <= ticks and has-arrived? = false] = 0] [
        move-to one-of neighbors with [item (item id direction) obstacle = 0 and persons-here with [delay <= ticks and has-arrived? = false] = 0]
      ]
    ]
    ]
    set count-interaction count-interaction + tempI

end



;;
; person procedure (to deal with density ?)
to temporary-increase-shortest-path [id]
  let i 0
  if [sum obstacle] of patch-here = 1 [
    set heading heading + 180
   if is-patch? patch-ahead radius  [
     fd radius
   ask patches in-radius radius  [
    set i 0
    while [i < length repartition-among-paths]
    [
    if i != id [
      set shortest-path-t replace-item i shortest-path-t min list (item i shortest-path-min + 3 * intensity) (item i shortest-path-t + intensity); (max [(item i shortest-path-t + intensity), (item i shortest-path-min + 2 * intensity)])
    ]
    set i i + 1
    ]
  ]
  fd -1 * radius
   ]
   set heading heading + 180
  ]
   ask patch-here [

      set shortest-path-t replace-item id shortest-path-t min list (item id shortest-path-min + 3 * intensity) (item id shortest-path-t + intensity); (max [(item i shortest-path-t + intensity), (item i shortest-path-min + 2 * intensity)])
]

   if is-patch? patch-ahead radius  [
     fd radius
   ask patches in-radius radius  [
    set i 0
    while [i < length repartition-among-paths]
    [
    if i != id [
      set shortest-path-t replace-item i shortest-path-t min list (item i shortest-path-min + 3 * intensity) (item i shortest-path-t + intensity); (max [(item i shortest-path-t + intensity), (item i shortest-path-min + 2 * intensity)])
    ]
    set i i + 1
    ]
  ]
  fd -1 * radius
   ]
end


